#####################################################################
####           CRDS Liquid Processing Functions                  ####
####      The functions in this file will look up the file       ####
####      names needed, run the functions from CRDS_liquid_1.R,  ####
####      format the data so it can be printed, plot the data,   #### 
####      upload the data to the database and write the data     ####
####      to an excel file                                       ####
#####################################################################

#####################################################################
##                      file.lookup function                       ##
##         This function retrieves file names for a given          ## 
##           machine and date using regular expressions            ## 
#####################################################################

file_lookup <- function(instrument, runDate){
  ## machine is the serial number of a Picarro instrument formatted 
  ## to match the formatting of the Dropbox file for that instrument
  ## (ie. hids2053, hids2052 or hids2046)
  
  if(nchar(runDate != 10)){stop("runDate format must be YYYY-MM-DD")}
  runDate = paste0(substr(runDate, 3, 4), substr(runDate, 6, 7), 
                   substr(runDate, 9, 10))
  ## change runDate to format yymmdd (eg. 150310)
  
  data.files <- list.files(instrument,full.names=T)
  ## returns list of files for the specified machine
  
  ids.files <- list.files(paste0(instrument,"/runfiles"),full.names=T)
  ## returns list of files in the 'runfiles' folder for the 
  ## specified machine, ie. the sample ids
  
  data.file <- tail(grep(runDate, data.files, value=TRUE), 1)
  ## returns filepath for last isotope file generated
  ## for the specified machine on the specified date

  ids.file <- tail(grep(runDate, ids.files, value=TRUE), 1)
  ## returns filepath for the last file with sample identifiers 
  ## for the specified machine on the specified date
  
  print(list(data.file=data.file,ids.file=ids.file))
  return(list(data.file=data.file,ids.file=ids.file))
}

#####################################################################
##                      check.files function                       ##
##         This function checks the data & ids files and           ## 
##           returns warnings if they are not formatted            ## 
##          correctly                                              ##
#####################################################################

check_files <- function(files){
  ## filenames is a list with filenamea for a data file & a sample
  ## ids file, such as that generated by the file.lookup function
  
  data <- read.csv(files$data.file, stringsAsFactors=FALSE, 
                   strip.white=TRUE)
  ## reads in the data csv
  
  if(any(c("Port", "Inj.Nr", "d.18_16.Mean", "d.D_H.Mean") %in% 
           names(data) == FALSE)){warning("data file is not correctly 
formatted, check that the machine and date are correct and that the
file is correctly formatted")} else {warning("data file correct")}
  ## checks that the necessary columns are present and returns
  ## warnings as to whether they are or not
  
  ids <- read.csv(files$ids.file,stringsAsFactors=FALSE,
                  strip.white=TRUE)
  ## reads in sample ids file
  
  names(ids) <- c("Tray","Port","ID","ID2")
  ## renames columns
  
  if(length(colnames(ids))!=4 |
       is.numeric(ids[,2])==FALSE | 
       is.character(ids[,3])==FALSE){warning("ids file is not
correctly formatted, check that the machine and date are correct,
that the file is named correctly, and that the file is correctly 
formatted")} else {warning("ids file correct")}
  ## checks formatting of sample ids table and returns warnings
  ## as to wehter it is correctly formatted or not
  
  data$Port<-as.numeric(regmatches(data$Port,regexpr(
    "[0-9][0-9]", data$Port)))
  ## identifies the numeric part of the port column and converts
  ## it to numeric data
  
  data.ports.freq <- as.data.frame(table(data$Port))
  ## creates a table with the frequency of each port in the data
  ## table
  
  names(data.ports.freq) <- c("Port","Freq")
  ## renames the columns in the frequency table
  
  data.ports.freq$Port <- as.numeric(data.ports.freq$Port)
  ## converts port column to numeric data
  
  if(any(data.ports.freq$Freq[data.ports.freq$Port>4] < 4) | 
       any(data.ports.freq$Freq[data.ports.freq$Port<=4] < 10)){
warning("Missing rows in data, save the data file as a 
new file and add '_toAnalyze' at the end of the filename 
then add in blank rows for missing data before running 
function process.data")} else {warning("data file complete")}
## checks if any ports have less than the required number
## of injections and returns warnings to indicate whether
## they do or not
  
  id_ports <- unique(ids$Port)
  ## generates unique list of ports in the sample ids table
  
  if(any(id_ports %in% data.ports.freq$Port == FALSE) |
       any(data.ports.freq$Port %in% id_ports == FALSE)){
warning("Ports are not the same for data.file and ids.file, 
check them and ensure they are the same before 
running function process.data")} else {warning("ids match")}
## checks that the ports listed in the sample ids table and the 
## data table are the same and returns warnings to indicate 
## whether they do or not
  
}

#####################################################################
##                      process.crds function                      ##
##              This function runs the functions in                ## 
##              'CRDS_liquid_correct_function.R' and               ## 
##              returns a list of 6 dataframes -                   ##
##       samples.summary - averaged and drift-corrected data       ## 
##       with quality flags non-reference samples                  ##
##       slrm.summary - summary data for the ports with the        ##
##       slrm reference                                            ##
##       ref.all - all data for references, including raw,         ## 
##       memory-corrected, and calibrated values                   ##
##       data.all - all data for samples, including raw,           ##
##       memory-corrected, and calibrated values                   ##
##       qa.report - summary of qa parameters for the run          ##
##       ref.compare - comparison of the mean of the 1st 4 &       ##
##       last 4 injections for the references in ports 2-4         ##
#####################################################################

process_data <- function(files){
  ## filenames is a list with filenamea for a data file & a sample
  ## ids file, such as that generated by the file.lookup function
  
  source("Bowen_Lab/R_scripts_active/CRDS_liquid_1.R")
  ## loads functions in this file
  
  qa.file <- "Bowen_Lab/Lab_Management/Reference_materials/CRDS_liquid_parameters.csv"
  ## stores the file name of the qa file
  
  qa.df <- read.csv(qa.file,stringsAsFactors=FALSE)
  ## reads in qa file
  
  plrm1 <- qa.df$ID[qa.df$parameter=="plrm1"]
  ## creates a character vector with the name of plrm1
  
  plrm2 <- qa.df$ID[qa.df$parameter=="plrm2"]
  ## creates a character vector with the name of plrm2
  
  slrm <- qa.df$ID[qa.df$parameter=="slrm"]
  ## creates a character vector with the name of slrm
  
  refs <- c(plrm1, plrm2, slrm)  
  
  df <- data.mod(data.file = files$data.file, 
                 ids.file = files$ids.file)
  ## data.mod function modifies & merges the data & sample ids files
  
  # add sequence number per injection
  df$seqN = seq_along(df[,1])
  
  mem <- mc.terms(df,3:4,1:10)
  ## mc.terms function generates memory-correction terms for the data
  
  df$d18O_mc <- data.mc(df,"O",mem)
  ## here the data.mc function applies memory-correction terms to the 
  ## d18O data
  
  df$d2H_mc <- data.mc(df,"H",mem)
  ## here the data.mc function applies memory-correction terms to the 
  ## d2H data
  
  drift <- drift.reg(df, qa.file, TRUE)
  ## drift.reg function calculates a regression line using the 
  ## mean value for each port with slrm and the sequence of the 
  ## port in the run for d18O & d2H data separately
  
  dc <- data.dc(df,drift)
  ## data.dc function applies the drift corrections to the data
  
  cal <- cal.reg(dc,qa.file)
  ## cal.reg function calculates a regression line using the known & 
  ## measured values for the d18O & d2H data separately
  
  d18O_cal = data.cal(dc, "O", cal)
  ## here the data.cal function calibrates the d18O data
  
  d2H_cal = data.cal(dc, "H", cal)
  dc$d2H_cm = d2H_cal$calMean
  dc$d2H_csd = d2H_cal$calSD

  dcal = cbind(dc, d18O_cm = d18O_cal$calMean, d18O_csd = d18O_cal$calSD,
               d2H_cm = d2H_cal$calMean, d2H_csd = d2H_cal$calSD)
  ## here the data.cal function calibrates the d2H data
  
  da = combine(dcal)
  
  flagged <- qa.flag(da,qa.file)
  ## qa.flag function evaluates the data against the predetermined
  ## qa cutoffs and flags 
  
  qa.report <- qa.summary(files$data.file,qa.file,mem,drift,
                          unlist(lapply(cal, mean)),flagged)
  ## qa.summary function summarizes the qa metrics for the run
  
  last4.ref <- df[df$ID %in% refs & df$inj>=7 & df$Port>1,]
  ## subsets df to include only data for plrm1, plrm2, slrm and
  ## exclude port 1 & injections lower than 7 (which excludes 
  ## any ports with less than 7 injections)
  
  last4.avg <- aggregate(last4.ref[,c("d18O_cal","d2H_cal")],
                         by=list(Port=last4.ref$Port,
                                 ID=last4.ref$ID),mean)
  ## calculates the means for the last 4 injections of each reference
  
  names(last4.avg) <- c("Port","ID","d18O_last4","d2H_last4")
  ## renames columns
  
  last4.sd <- aggregate(last4.ref[,c("d18O_cal","d2H_cal")],
                         by=list(Port=last4.ref$Port,
                                 ID=last4.ref$ID),sd)
  ## calculates the sd for the last 4 injections of each reference
  
  names(last4.sd) <- c("Port","ID","d18O_last4_sd","d2H_last4_sd")
  ## renames columns
  
  last4.avg <- merge(last4.avg,last4.sd,by=c("Port","ID"))
  ## merges mean & sd tables
  
  first4.ref <- df[df$ID %in% c(plrm1,plrm2,slrm) & df$inj<=4 & 
                     df$Port>1 & df$Port<=4,]
  ## subsets df to include only data for plrm1, plrm2, slrm and
  ## only for ports 2-4 & injections higher than 4
  
  first4.avg <- aggregate(first4.ref[,c("d18O_cal","d2H_cal")],
                          by=list(Port=first4.ref$Port,
                                  ID=first4.ref$ID),mean)
  ## calculates the means for the 1st 4 injections of each reference
  
  names(first4.avg) <- c("Port","ID","d18O_1st4","d2H_1st4")
  ## renames columns
  
  diff <- merge(first4.avg,last4.avg,by=c("Port","ID"))
  ## merges first 4 & last 4 data
  
  diff$d18O_diff <- diff$d18O_1st4 - diff$d18O_last4
  ## calculates difference in 1st 4 & last 4 means for d18O
  
  diff$d2H_diff <- diff$d2H_1st4 - diff$d2H_last4
  ## calculates difference in 1st 4 & last 4 means for d2H
  
  qa.df2 <- qa.df[10:12,c(2,5,6)]
  ## subsets qa.df to include only rows 10-12 & columns 2, 5 & 6
  
  diff <- merge(diff, qa.df2)
  ## merges diff & qa.df2
  
  samples.summary <- flagged[flagged$ID != slrm,]
  ## subsets flagged df to include only non-reference data
  
  slrm.summary <- flagged[flagged$ID == slrm,]
  ## subsets flagged df to inlcude only data for slrm
  
  ref.all <- df[df$ID %in% c(plrm1,plrm2,slrm),]
  ## subsets df to include only data for references
  
  data.all <- df[df$ID %in% c(plrm1,plrm2,slrm)==FALSE,]
  ## subsets df to include only non-reference data
  
  return(list(samples.summary = samples.summary, 
              slrm.summary = slrm.summary, 
              ref.all = ref.all, 
              data.all = data.all, 
              qa.report = qa.report, 
              ref.compare = diff))
}


#####################################################################
##                      print.format function                      ##
##              This function formats the dataframes               ##
##              created in process.crds for printing               ##
##              to the console                                     ##
#####################################################################

print_format <- function(data){
  ## data is a list of dataframes such as that created by the 
  ## process.crds function that includes qa.report & samples.summary
  
  qa.print <- data$qa.report
  ## stores the dataframe qa.report
  
  qa.print$value[3:20] <- round(as.numeric(qa.print$value[3:20]),3)
  ## rounds all of the numeric values in qa.print to 3 decimals

  samples.s <- data$samples.summary
  ## stores the dataframe samples.summary

  samples.s <- samples.s[,c("Port","ID","ID2","d18O_dc", "d2H_dc",
                          "d18O_sd","d2H_sd","ignore_run",
                          "ignore_sample")]
  ## subsets the dataframe to include only certain columns

  names(samples.s)[4:5] <- c("d18O","d2H")
  ## renames columns 4 & 5

  samples.s[,4:7] <- round(samples.s[,4:7],2)
  ## rounds columns 4-7 to 2 decimal places

  return(list(qa = qa.print, samples.summary = samples.s))
}

#####################################################################
##                      plot.gmwl function                         ##
##          This function plots the data against the GMWL          ##
#####################################################################

plot_gmwl <- function(data){
  ## data is a dataframe such as the samples.summary table created
  ## by the print.format function
  
  o <- c(min(data$d18O,na.rm=T),max(data$d18O,na.rm=T))
  ## creates a vector with the minimum and maximum d18O values
  
  h <- o*8+10
  ## creates a vector with result of multiplying the minimum and 
  ## maximum d18O values by 8 and adding 10
  
  reg <- lm(h~o)
  ## calculates regression for o & h
  
  h.min <- if(h[1] < min(data$d2H,na.rm=T)){h[1]
  } else {min(data$d2H,na.rm=T)}
  ## compares the minimum calculated value to the minimum measured 
  ## value and returns the lowest of the 2 to be used to set the
  ## plotting boundaries
  
  h.max <- if(h[2] > max(data$d2H,na.rm=T)){h[2]
  } else {max(data$d2H,na.rm=T)}
  ## compares the maximum calculated value to the maximum measured 
  ## value and returns the greatest of the 2 to be used to set the
  ## plotting boundaries
  
  plot(data$d18O,data$d2H,main="d18O v. d2H with GMWL",xlim = o, 
       ylim = c(h.min,h.max), xlab="d18O",ylab="d2H")
  abline(reg)
}

#####################################################################
##                      review.data function                       ##
##            This function runs the print.format &                ##  
##            plot.gmwl functions & prints the relevant            ##
##            dataframes & plot to the console for review          ##
#####################################################################
review_data <- function(data){
  ## data is a list of dataframes such as that created by the 
  ## process.crds function that includes qa.report & samples.summary
  
  print.me <- print_format(data)
  ## runs print.format function

  plot_gmwl(print.me$samples.summary)
  ## runs plot.gmwl function
  
  print(list(qa = print.me$qa,
           data = print.me$samples.summary))
}

#####################################################################
##                         db function                             ##
##              This function writes the data to the               ##   
##              Water_DB Access database if it does not            ##
##              already exist in the database                      ##
#####################################################################

db <- function(data, analyst){
  ## data is a list of dataframes such as that created by the 
  ## process.crds function that includes qa.report & samples.summary

  library(RODBC)
  ## loads RODBC library

  qa <- data$qa.report
  ## stores the qa.report table
  
  Instrument <- qa$value[1]
  ## stores the instrument name
  
  Run_date <- qa$value[2]
  Run_date = as.Date(Run_date, format = "%m/%d/%y")
  ## stores the run date
  
  channel = odbcConnect("WIDB")
  ## creates a connection to the database, must be loaded as ODBC source w/ this name

  existing <- sqlQuery(channel, paste0("SELECT * FROM Parameters_table 
               WHERE Instrument = '",Instrument, "' AND 
               Run_date = '",Run_date,"'"))
  ## creates a table with data that matches the instrument and
  ## run date if it exists

  if(nrow(existing)>0){
    vdupes = readline(prompt="Duplicate run entry found in database. View (Y/N)?")
    if(vdupes!="N") print(existing)
    ddupes = readline(prompt="Delete (Y/N)?")
    if(ddupes=="Y"){ 
      sqlQuery(channel, paste0("DELETE FROM Parameters_table WHERE Instrument = '", 
                               Instrument, "' AND Run_date = '", Run_date, "'"))
    } else {stop("data already present in database, no new data imported")}
  }
  ## finds duplicates in the existing table and prompts for user prefered action 
  
  n1 = sqlQuery(channel, "SELECT COUNT(*) FROM Parameters_table")
  sqlQuery(channel,paste0("INSERT INTO Parameters_table(Instrument,
    Run_date, Memory1_O, Memory2_O, Memory3_O, Memory4_O, Drift1_O, 
    Slope_O, Intercept_O, Memory1_H, Memory2_H, Memory3_H, Memory4_H, 
    Drift1_H, Slope_H, Intercept_H, PT_O_ave, PT_H_ave, PT_O_sd, PT_H_sd, 
    PT_count, Ignore_run, Analyst) 
                        VALUES('",Instrument,"','", Run_date,"',",
                        qa$value[3], ",", qa$value[4], ",", 
                        qa$value[5], ",", qa$value[6],",",
                        qa$value[7], ",", qa$value[8], ",",
                        qa$value[9], ",", qa$value[10], ",",
                        qa$value[11], ",", qa$value[12],",",
                        qa$value[13], ",", qa$value[14], ",",
                        qa$value[15], ",", qa$value[16], ",",
                        qa$value[17], ",", qa$value[18],",",
                        qa$value[19], ",", qa$value[20], ",",
                        qa$value[21], ",", qa$value[22], ", '",
                        analyst, "')"))
  ## writes data to the Parameters_table in the database
  n2 = sqlQuery(channel, "SELECT COUNT(*) FROM Parameters_table")
  print(paste(n2-n1, "parameter set imported"))
  
  s <- data$samples.summary
  ## stores the samples.summary table
  
  s$Ignore <- ifelse(s$ignore_run == 1 | s$ignore_sample == 1, 1, 0)
  ## creates a single column that determines whether a sample should be ignored
  
  for (i in 1:nrow(s)){
    if(!is.na(s$ID2[i]) && s$ID2[i] != ""){
      s$Sample_ID[i] = paste0(s$ID2[i], "_", s$ID[i])
    } else {
      s$Sample_ID[i] = as.character(s$ID[i])
    }
  }
  ## creates a single column that stores composite ID
  
  existing = sqlQuery(channel, "SELECT * FROM Water_Isotope_Data WHERE Sample_ID = NULL")
  for(i in 1:nrow(s)){
    existing = rbind(existing, sqlQuery(channel, paste0("SELECT * FROM Water_Isotope_Data 
               WHERE WI_Analysis_Instrument = '", Instrument, "' AND 
               WI_Analysis_Date = '", Run_date,"' AND Sample_ID = '", s$Sample_ID[i], "'")))
  }
  if(nrow(existing)>0){
    vdupes = readline(prompt="Duplicate sample data found in database. View (Y/N)?")
    if(vdupes!="N") print(existing)
    ddupes = readline(prompt="Delete (Y/N)?")
    if(ddupes=="Y"){ 
      for(i in 1:nrow(existing)){
        sqlQuery(channel, paste0("DELETE FROM Water_Isotope_Data WHERE WI_Analysis_ID = '", existing$WI_Analysis_ID[i], "'"))
      }
    } else {stop("data already present in database, no new data imported")}
  }
  ## creates a table with data that matches the instrument, run date,
  ## and sample ID if it exists

  wids = sqlQuery(channel, "SELECT WI_Analysis_ID FROM Water_Isotope_Data WHERE WI_Analysis_ID LIKE 'SPATIAL%'")
  wid_nums = as.integer(substring(wids$WI_Analysis_ID, regexpr("_", wids$WI_Analysis_ID)+1))
  widmax = max(wid_nums)
  ## retrieves analysis IDs for SPATIAL samples and finds maximum value

  n1 = sqlQuery(channel, "SELECT COUNT(*) FROM Water_Isotope_Data")
  for(i in 1:nrow(s)){
    qstring = paste0("INSERT INTO Water_Isotope_Data (WI_Analysis_ID, Sample_ID, d2H, d18O, d2H_Analytical_SD, d18O_Analytical_SD, WI_Analysis_Date, WI_Analysis_Source, WI_Analysis_Instrument, WI_Analysis_Ignore)
           VALUES('SPATIAL_", widmax+i, "', '", s$Sample_ID[i], "', ", s$d2H_dc[i], ", ", s$d18O_dc[i], ", ", s$d2H_sd[i], ", ", s$d18O_sd[i], ", '", Run_date, "', 'SPATIAL','",  Instrument, "', ", s$Ignore[i], ")")
    qstring = gsub(",NaN,", ",NULL,", qstring)
    qstring = gsub(",NA,", ",NULL,", qstring)
    sqlQuery(channel, qstring)
  }
  n2 = sqlQuery(channel, "SELECT COUNT(*) FROM Water_Isotope_Data")
  print(paste(nrow(s), "samples in file"))
  print(paste(n2-n1, "samples imported"))
  ## writes data to the DB table, analysis ID is autogenerated with prefix and 
  ## incremented integer suffix 

close(channel)
## closes the connection to the database
}

#####################################################################
##                         excel function                          ##
##              This function writes the tables to an              ##
##              xlsx file with tabs for each table                 ##
#####################################################################

excel <- function(file,data){
  ## file is the filename of a csv with sample ids formatted 
  ## with the date, sample description, and machine name (e.g. 
  ## 150310_SIRFER 14-217_HIDS2046.csv)
  ## data is a list of dataframes such as that created by the 
  ## process.crds function that includes 6 tables
  

  library(openxlsx)
  ## loads openxlsx library

  output_file <- sub("hids2046/runfiles/|hids2053/runfiles/|hids2052/runfiles/",
                     "",file)
  ## creates a filename to be used for the excel file by modifying
  ## the sample ids filename
  
  output_file <- sub(".csv",".xlsx",output_file)
  ## modifies output_file with the correct file extension
  
  output_file <- paste0("Bowen_Lab/CRDS_liquidH2O/",output_file)
  ## modifies output_file with the filepath information

  if(file.exists(output_file)){file.remove(output_file)}
  ## removes the output_file if it already exists
  
  wb <- createWorkbook()
  ## creates an empty excel workbook
  
  lapply(names(data), function(x) addWorksheet(wb, sheetName=x))
  ## creates one tab in the workbook for each of the tables
  ## in data
  
  lapply(names(data), function(x) writeData(wb, sheet=x, data[[x]]))
  ## writes each table in data to corresponding worksheet

  saveWorkbook(wb, output_file)
  ## saves the excel workbook to the filename specified by
  ## output_file
  
}
